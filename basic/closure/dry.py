# 중복 배제 (Don't repeat yourself; DRY)는 소프트웨어 개발 원리의 하나로, 모든 형태의 정보 중복을 지양하는 원리이다. 
# 특히 다층 구조 시스템에서 유용하다. 
# 중복배제 원리는 한마디로 “모든 지식은 시스템 내에서 유일하고 중복이 없으며 권위있는 표상만을 가진다”는 말로 기술


def add(x, y):
    """Add Function"""
    return x + y


def subtract(x, y):
    """Subtract Function"""
    return x - y


def multiply(x, y):
    """Multiply Function"""
    return x * y


def divide(x, y):
    """Divide Function"""
    if y == 0:
        raise ValueError('Can not divide by zero!')
    return x / y




























# SOLID (객체 지향 설계)
  # 단일 책임 원칙(S)
  # 개방-폐쇄 원칙(O)
  # 리스코프 치환 원칙(L)
  # 인터페이스 분리 원칙(I)
  # 의존관계 역전 원칙(D)
# YAGNI
# 검은 상자
# 관심사 분리
# 놀람 최소화 원칙
# 방어적 프로그래밍
# 중복배제

# 프로그래밍 원칙 : SOLID (객체 지향 설계)
# SOLID (객체 지향 설계)
# 단일 책임 원칙(S) : 모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 함을 일컫는다. 클래스가 제공하는 모든 기능은 이 책임과 주의 깊게 부합해야 한다. 이 용어는 로버트 마틴이 그의 저서 기민한 소프트웨어 개발과 원칙, 패턴, 실례[1]으로 유명해진 객체 지향 설계 원칙[2]이란 문서의 같은 이름을 가진 단락에서 소개되었다. 로버트 마틴은 이를 톰 디마르코의 책 구조적 분석과 시스템 명세[3]에서 설명한 응집성 원칙에 근거하여 설명하였다. 로버트 마틴은 책임을 변경하려는 이유로 정의하고, 어떤 클래스나 모듈은 변경하려는 단 하나 이유만을 가져야 한다고 결론 짓는다. 예를 들어서 보고서를 편집하고 출력하는 모듈을 생각해 보자. 이 모듈은 두 가지 이유로 변경될 수 있다. 첫 번째로 보고서의 내용 때문에 변경될 수 있다. 두 번째로 보고서의 형식 때문에 변경될 수 있다. 이 두 가지 변경은 하나는 실질적이고 다른 하나는 꾸미기 위한 매우 다른 원인에 기인한다. 단일 책임 원칙에 의하면 이 문제의 두 측면이 실제로 분리된 두 책임 때문이며, 따라서 분리된 클래스나 모듈로 나누어야 한다. 다른 시기에 다른 이유로 변경되어야 하는 두 가지를 묶는 것은 나쁜 설계일 수 있다. 한 클래스를 한 관심사에 집중하도록 유지하는 것이 중요한 이유는, 이것이 클래스를 더욱 튼튼하게 만들기 때문이다. 앞서 든 예를 계속 살펴보면, 편집 과정에 변경이 일어나면, 같은 클래스의 일부로 있는 출력 코드가 망가질 위험이 대단히 높다.
# 개방-폐쇄 원칙(O) : 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
# 소프트웨어 개발 작업에 이용된 많은 모듈 중에 하나에 수정을 가할 때 그 모듈을 이용하는 다른 모듈을 줄줄이 고쳐야 한다면, 이와 같은 프로그램은 수정하기가 어렵다. 개방-폐쇄 원칙은 시스템의 구조를 올바르게 재조직(리팩토링)하여 나중에 이와 같은 유형의 변경이 더 이상의 수정을 유발하지 않도록 하는 것이다. 개방-폐쇄 원칙이 잘 적용되면, 기능을 추가하거나 변경해야 할 때 이미 제대로 동작하고 있던 원래 코드를 변경하지 않아도, 기존의 코드에 새로운 코드를 추가함으로써 기능의 추가나 변경이 가능하다.
# 개방-폐쇄 원칙의 두 가지 속성
# 1. 확장에 대해 열려 있다 : 이것은 모듈의 동작을 확장할 수 있다는 것을 의미한다. 애플리케이션의 요구 사항이 변경될 때, 이 변경에 맞게 새로운 동작을 추가해 모듈을 확장할 수 있다. 즉, 모듈이 하는 일을 변경할 수 있다.
# 2. 수정에 대해 닫혀 있다 : 모듈의 소스 코드나 바이너리 코드를 수정하지 않아도 모듈의 기능을 확장하거나 변경할 수 있다. 그 모듈의 실행 가능한 바이너리 형태나 링크 가능한 라이브러리(예를 들어 윈도의 DLL이나 자바의 .jar)를 건드릴 필요가 없다.
# 추상화를 통한 개방-폐쇄 원칙 : 객체 지향 프로그래밍 언어(JAVA, C++ 등)에서는 고정되기는 해도 제한되지는 않은, 가능한 동작의 묶음을 표현하는 추상화가 가능하다. 모듈은 추상화를 조작할 수 있다. 이런 모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있고, 반대로 추상화의 새 파생 클래스를 만드는 것을 통해 확장도 가능하다. 따라서 추상화는 개방-폐쇄 원칙의 핵심 요소이다.
# 개방-폐쇄 원칙과 객체 지향 언어의 관계 : 개방-폐쇄 원칙은 객체 지향 프로그래밍의 핵심 원칙이라고 할 수 있다. 개방-폐쇄 원칙을 따르지 않는다고 해서 객체 지향 언어(Java, C++ 등)을 구현이 불가능한 것은 아니지만 이 원칙을 무시하고 프로그래밍을 한다면, 객체 지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 결코 얻을 수 없다. 따라서 객체 지향 프로그래밍 언어에서 개방-폐쇄 원칙은 반드시 지켜야할 기본적인 원칙이다.
# 리스코프 치환 원칙(L) : 컴퓨터 프로그램에서 자료형 S가 자료형 T의 하위형이라면 필요한 프로그램의 속성(정확성, 수행하는 업무 등)의 변경 없이 자료형 T의 객체를 자료형 S의 객체로 교체(치환)할 수 있어야 한다는 원칙. 자료 추상화와 계층 (Data abstraction and hierarchy)이라는 제목으로 기조연설을 한 1987년 컨퍼런스에서 처음 소개한 내용으로, 이 원칙을 엄밀한 용어로 말하자면 (강한) 행동적 하위형화라 부르는 하위형화 관계의 특정한 사례이다. 이 정의는 1994년 논문에서 다음 원칙을 만들어낸 자료형의 의미론적 상호처리를 보장하기 때문에 단순한 문법적 관계일 뿐만 아니라 의미론적 관계다. q(x)를 자료형 T의 객체 x에 대해 증명할 수 있는 속성이라 하자. 그렇다면 S가 T의 하위형이라면 q(y)는 자료형 S의 객체 {\displaystyle y}y에 대해 증명할 수 있어야 한다. 같은 논문에서 리스코프와 윙은 사전 및 사후 조건으로 하위형화의 상호 작용을 고려함으로써 행동 하위형화 개념을 베르트랑 메이어의 계약에 의한 설계와 분명한 유사성을 지닌 호어 논리의 확장으로 자세히 설명한다.
# LSP를 위반하는 전형적인 예로, 너비와 높이의 조회(getter) 및 할당(setter) 메서드를 가진 직사각형 클래스로부터 정사각형 클래스를 파생하는 경우를 들 수 있다. 정사각형 클래스는 항상 너비와 높이가 같다고 간주할 수 있다. 정사각형 객체가 직사각형을 다루는 문맥에서 사용되는 경우, 정사각형의 크기는 독립적으로 변경할 수 없기 때문에 (혹은 그래서는 안되기 때문에) 예기치 못한 행동을 하게 된다. 이 문제는 고치기 쉽지 않다. 정사각형 클래스의 할당 메서드를 수정하여 정사각형의 불변 조건(즉, 너비와 높이가 같음)을 유지하면, 이 메서드는 크기를 독립적으로 변경할 수 있다고 설명한 직사각형의 할당자의 사후 조건을 무력화(위반)한다. 이러한 LSP 위반은 실전에서는 LSP를 위반한 클래스를 사용하는 코드가 실제로 기대하는 사후 조건이나 불변 조건에 따라 문제가 될 수도 있고 아닐수도 있다. 여기서 중요한 사안은 가변성이다. 정사각형과 직사각형이 조회 메서드만 가진다면 (즉, 이들이 불변 객체라면), LSP 위반을 발생하지 않는다.
# 원칙
# 리스코프의 '행동적 하위형'이라는 개념은 '가변 객체의 치환성'이라는 개념을 정의한다. 즉 자료형 {\displaystyle S}S가 자료형 {\displaystyle T}T의 하위형이라면, 프로그램에서 자료형 {\displaystyle T}T의 객체는 프로그램의 속성을 변경하지 않고 자료형 {\displaystyle S}S의 객체로 교체할 수 있다. (예: 정확성) 행동의 하위형화는 형 이론에서 인수형의 반공변성과 반환형의 공변성에 의존하여 정의한 일반적 기능의 하위형화보다 더 강한 개념이다. 행동의 하위형은 일반적으로 명백하게 결정 불가능하다. "{\displaystyle x}x에 대해 항상 종료할 수 있는 메서드"라는 속성을 {\displaystyle q}q라고 할 때, 임의의 프로그램(예: 컴파일러)이, 속성 {\displaystyle q}q가 자료형 {\displaystyle T}T에 대해 참임을 유지한다 하더라도 자료형 {\displaystyle T}T의 어떤 하위형 {\displaystyle S}S에 대해 참을 유지한다는 것을 증명하기란 불가능하다. 그럼에도 불구하고 이 원칙은 클래스의 계층 구조를 설계할 때 유용하다. 리스코프의 원칙은 새로운 객체 지향 프로그래밍 언어에 채용된 시그니처에 관한 몇 가지 표준적인 요구사항을 강제한다. 
# 1. 하위형에서 메서드 인수의 반공변성
# 2. 하위형에서 반환형의 공변성
# 3. 하위형에서 메서드는 상위형 메서드에서 던져진 예외의 하위형을 제외하고 새로운 예외를 던지면 안된다.
# 여기에 더하여 하위형이 만족해야하는 행동 조건 몇 가지가 있다. 이것은 계약이 상속에 대해 어떻게 상호작용하는지에 대한 제약조건을 유도하는 계약에 의한 설계 방법론과 유사한 용어로 자세히 설명되어있다.
# 1. 하위형에서 선행조건은 강화될 수 없다.
# 2. 하위형에서 후행조건은 약화될 수 없다.
# 3. 하위형에서 상위형의 불변조건은 반드시 유지되어야 한다.
# 이력 제약 조건 (이력 규칙). 객체는 그 자신의 메서드를 통해서만 수정(캡슐화)할 수 있는 것으로 간주된다. 하위형은 상위형에 없는 메서드를 추가할 수 있기 때문에, 추가된 메서드를 통해 상위형에서 허용하지 않는 하위형 상태의 변경을 일으킬 수 있다. 리스코프와 윙이 도입한 참신한 요소인 이력 제약조건은 이를 방지한다. 이 제약조건의 위반을 정의하기 위해 변경 가능 지점을 변경 불가 지점의 하위형으로 정의해 볼 수 있다. 변경 불가 지점의 이력은 생성한 이후 상태가 항상 동일해야 하기 때문에, 앞에서 가정한 정의는 이력 제약조건의 위반이며, 따라서 일반적으로 변경 가능 위치를 이력에 포함할 수 없다. 반면 하위형에 추가된 필드는 상위형의 메서드로 감시할 대상이 아니기 때문에 안정적으로 수정할 수 있다. 따라서 고정된 점에서 고정된 중심점과 변경 가능한 반지름을 가진 원을 LSP를 위반하지 않고 유도할 수 있다.
# 인터페이스 분리 원칙 (I)
# 의존관계 역전 원칙 (D)

# YAGNI : YAGNI[1](You aren't gonna need it[2][3])는 프로그래머가 필요하다고 간주할 때까지 기능을 추가하지 않는 것이 좋다는 익스트림 프로그래밍(XP)의 원칙이다.[4] 익스트림 프로그래밍의 공동 설립자 론 제프리스는 다음과 같이 썼다: "실제로 필요할 때 무조건 구현하되, 그저 필요할 것이라고 예상할 때에는 절대 구현하지 말라."
# 검은 상자
# 관심사 분리
# 놀람 최소화 원칙
# 방어적 프로그래밍
# 중복배제

